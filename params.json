{"note":"Don't delete this file! It's used internally to help with page regeneration.","body":"short-memory\r\n============\r\n\r\nSimple node.js in-memory caching library.\r\n\r\nCreates basic structures for storing arbitrary data for future use, able to be\r\nlimited by entry count, entry age, or cache size.\r\n\r\n## Installation\r\n\r\n    $ npm install short-memory\r\n\r\n## Simple usage\r\n```js\r\nvar ShortMemory = require('short-memory');\r\n\r\nvar options = {};\r\n\r\nvar cache = new ShortMemory(options);\r\n\r\n// Set and get can be called async or sync by providing or excluding \r\n// a callback function. Sync requests return the result directly to \r\n// the calling \r\nexpression;\r\ncache.set(\"First!\", {important: \"data\"});\r\n\r\n// async requests have the result passed to the given function.\r\ncache.get(\"First!\", function(err, result) {\r\n  // Logs: {important: \"data\"}\r\n  console.log(err || result);\r\n});\r\n```\r\n\r\n## Options\r\n\r\nShortMemory can be initialized with several options, which you can use to limit \r\nthe size and alter the behavior of the cache:\r\n```js\r\nvar options = {\r\n  // How long, in seconds, it takes for an entry to expire and become\r\n  // prunable. Defaults to 0, which does not set expirations for \r\n  // entries. This can be over-ridden by the options passed when \r\n  // setting a cache entry.\r\n  maxAge: 60,\r\n  \r\n  // How large the (estimated*) size of the cache can be before \r\n  // pruning old entries. Defaults to 0, which does not set a \r\n  // maximum size.\r\n  maxSize: 5000,\r\n  // * Size estimations are best-guess. This method should be \r\n  // last resort, perhaps used as a fail-safe against enormous \r\n  // data retention.\r\n  \r\n  // How many entries the cache can hold before pruning the \r\n  // oldest entries. Defaults to 0, which allows any number of \r\n  // entries.\r\n  maxCount: 100,\r\n  \r\n  // How often the system checks for and destroys obsolete \r\n  // entries, in seconds. Defaults to 5.\r\n  pruneTime: 5,\r\n  \r\n  \r\n  // When an entry is this many seconds from expiring, the \r\n  // system should return the current value on request and kick \r\n  // off a process to update the value afterwards. This is used \r\n  // by the getOrSet function. This can be over-ridden by the \r\n  // options passed when setting a cache entry.\r\n  deathTime: 0,\r\n  \r\n  // Writes verbose output to the console for debugging.\r\n  debug: false\r\n  \r\n};\r\nvar cache = new ShortMemory(options);\r\n```\r\n\r\n## Functions\r\n\r\n```js\r\n// Let's start with the following assumption:\r\nvar ShortMemory = require(\"short-memory\");\r\nvar cache = new ShortMemory({maxCount: 10});\r\n```\r\n\r\n### .set(key, value [, options] [, callback])\r\n\r\nSets the key to the given value. When successful, it responds with the\r\nvalue of the given entry's value. This function can be called asynchronously\r\nby providing a callback function, which receives data in the expected\r\n`(err, data)` format.\r\n\r\nWhen called synchronously, the value of the key is returned to the calling \r\nexpression when successful; when unsuccessful, it returns `null`.\r\n\r\n```js\r\ncache.set(\"name\", \"Andrew\");\r\n\r\ncache.set(\"food\", \"Pizza\", function(err, data) {\r\n  if (err) throw err;\r\n  else console.log(data);\r\n});\r\n\r\ncache.set(\"animal\", \"Panda\", {maxAge: 120, deathTime: 30}, function(err, result) {\r\n  // maxAge and deathTime can be over-ridden on an entry basis\r\n});\r\n```\r\n\r\n### .get(key [, callback])\r\n\r\nRetrieves the value for the given key. This responds just as .set does.If\r\nasync, it calls back with `(err, data)`. If sync, it either returns the value\r\nof the key, or `null`.\r\n\r\n```js\r\n// \"Andrew\"\r\nconsole.log(cache.get(\"name\"));\r\n\r\ncache.get(\"food\", function(err, data) {\r\n  if (err) throw err;\r\n  // \"Pizza\"\r\n  else console.log(data);\r\n});\r\n\r\n// \"Panda\"\r\ncache.get(\"animal\", console.log.bind(console));\r\n```\r\n\r\n### .getOrSet(key, setback [, options] [, callback])\r\n\r\nThis is what you will most likely use, but I thought I'd explain those other\r\ntwo first.\r\n\r\nRetrieves the value of the given key. If the key has expired or does not exist,\r\nit calls setback, which it expects to return the new value. It then updates the\r\nvalue, and returns the new value.\r\n\r\nA callback can be specified to run asynchronously. Additionally, if the `async`\r\noption is set to `true`, the setback will be called with next function that \r\nwraps the key update and given callback function. See the third example.\r\n\r\nAdditionally, if the key has a `deathTime` of anything other than 0, cache entries\r\nget treated differently by this function. If an entry is requested that is within\r\nits `deathTime` (given seconds away from its expiration), the function will return\r\nor callback with the current value immediately, and then follow up with an update\r\nafter-the-fact. (Instant gratification, deferred update, all goodness.)\r\n\r\n```js\r\n// Since \"name\" exists and is valid, Andrew is returned\r\nvar myName = cache.getOrSet(\r\n  \"name\",\r\n  // If it didn't, it would update and return \"Aejay\"\r\n  function() {\r\n    return \"Aejay\";\r\n  }\r\n);\r\n\r\nvar myFood;\r\ncache.getOrSet(\r\n  \"food\",\r\n  // If \"food\" didn't exist, we would use our own LookupFunction to\r\n  // figure out the value, which would then be stored and the\r\n  // callback would set myFood to the new value.\r\n  function(key) {\r\n    return LookupFunction(key);\r\n  },\r\n  // Since \"food\" exists, though, myFood gets set to \"Pizza\"\r\n  function(err, data) {\r\n    myFood = data;\r\n  }\r\n);\r\n\r\n// Pandas are not practical pets.\r\nvar myAnimal;\r\ncache.getOrSet(\r\n  \"animal\",\r\n  // The \"next\" function is provided to us when we specify the async\r\n  // option.\r\n  function(key, next) {\r\n    // If we have an async version of our LookupFunction, we can use\r\n    // it here...\r\n    LookupFunctionAsync(key, function(data) {\r\n      // ... and assign its response to the value by calling the \r\n      // given next() function\r\n      next(data);\r\n      // next sets the key to the given value, and then fires the \r\n      // callback parameter.\r\n    });\r\n  },\r\n  {async:true},\r\n  // Ultimately, our callback gets called. Since \"animal\" does exist,\r\n  // myAnimal gets set to \"Panda\".\r\n  function(err, data) {\r\n    myAnimal = data;\r\n  }\r\n);\r\n// Seriously, though, kids. Leave the care of endangered species \r\n// to the professionals!\r\n```\r\n\r\n### .destroy(key [, callback])\r\n\r\nDoes what it sounds like. You can use this function to manually discard an\r\nentry in your cache. Will respond with `true` if it succeeded, or `false` if\r\nthe key did not exist or could not (for whatever odd reason) be deleted.\r\n\r\n```js\r\n// true\r\ncache.destroy(\"food\");\r\n// null\r\ncache.get(\"food\");\r\n\r\n// false (it doesn't exist)\r\ncache.destroy(\"Planet Pluto\");\r\n// still null\r\ncache.get(\"Planet Pluto\");\r\n\r\n// Sorry if that destroys your childhood like it did mine.\r\n```\r\n\r\n### .isHealthy(key)\r\n\r\nThis function is only useful if a key has an expiration (`maxAge`) and a\r\n`deathTime`. It can be used to determine if a key is healthy (ie: it is not\r\nexpired, and is not within `deathTime` seconds from expiring). If it is not\r\nhealthy, the application may choose to manually update the entry, or take\r\nwhatever other needed course of action.\r\n\r\n```js\r\n// false (We destroyed it, remember? Destruction isn't healthy.)\r\ncache.isHealthy(\"food\");\r\n\r\n// true\r\ncache.isHealthy(\"animal\");\r\n```\r\n\r\n## Building\r\n\r\nIf you'd like to compile the coffeescript to javascript yourself, simply use\r\ncake:\r\n\r\n```\r\n$ cake\r\nCakefile defines the following tasks:\r\n\r\ncake build    # build the short-memory library from source\r\ncake watch    # watch the source files for changes, and build\r\n\r\n  -m, --minify       define whether to also minify build or watch\r\n  -t, --test         run and output tests/coverage to test directory\r\n\r\n$ cake build\r\nCompiling: src\\short-memory.coffee\r\n```\r\n\r\n## Credits\r\n\r\nThis library was inspired by [memcached](http://memcached.org/) (in spirit, \r\nbut not in source).\r\n\r\n## License\r\n\r\n&copy;2012 Aejay Goehring and available under the MIT license:\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of \r\nthis software and associated documentation files (the \"Software\"), to deal in \r\nthe Software without restriction, including without limitation the rights to \r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \r\nof the Software, and to permit persons to whom the Software is furnished to do \r\nso, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all \r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, \r\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN \r\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n","name":"short-memory","tagline":"Simple node.js in-memory caching library.","google":"UA-36363114-1"}