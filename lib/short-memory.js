// Generated by CoffeeScript 1.4.0
(function() {
  var ShortMemory;

  ShortMemory = (function() {
    var constructor;

    function ShortMemory() {}

    ShortMemory.prototype.heap = {};

    ShortMemory.prototype.Memorable = require('./memorable.js');

    ShortMemory.prototype.maxSize = 0;

    ShortMemory.prototype.maxRecords = 0;

    ShortMemory.prototype.maxAge = 0;

    ShortMemory.prototype.pruneTime = 5;

    ShortMemory.prototype.debug = false;

    constructor = function(options) {
      var _ref, _ref1, _ref2, _ref3, _ref4;
      if (options == null) {
        options = {};
      }
      if ((_ref = options.maxSize) == null) {
        options.maxSize = 0;
      }
      if ((_ref1 = options.maxRecords) == null) {
        options.maxRecords = 0;
      }
      if ((_ref2 = options.maxAge) == null) {
        options.maxAge = 0;
      }
      if ((_ref3 = options.pruneTime) == null) {
        options.pruneTime = 5;
      }
      if ((_ref4 = options.debug) == null) {
        options.debug = false;
      }
      this.maxSize = options.maxSize;
      this.maxRecords = options.maxRecords;
      this.maxAge = options.maxAge;
      this.debug = options.debug;
      this.pruneTime = options.pruneTime * 1000;
      return (function() {
        return this.prune;
      })();
    };

    ShortMemory.prototype.set = function(key, data, options, callback) {
      var memorable;
      try {
        memorable = new Memorable(key, data, options);
        heap[key] = memorable;
        return callback(null, memorable.data);
      } catch (ex) {
        console.error("Unable to set memorable: " + ex);
        return callback(ex);
      }
    };

    ShortMemory.prototype.get = function(key, callback) {
      return process.nextTick(function() {
        var value;
        value = this.heap[key];
        if (typeof value === 'undefined') {
          return callback({
            type: "notfound",
            message: "Key " + key + " not found in heap."
          });
        } else {
          if (value.IsExpired() || value.Invalid) {
            this.destroy(key);
            return callback({
              type: "invalid",
              message: "Key " + key + " is invalid or expired."
            });
          } else {
            return callback(null, value.data);
          }
        }
      });
    };

    ShortMemory.prototype.getOrSet = function(key, options, callback, setback) {
      return this.get(key, function(error, value) {
        if (error) {
          if (error.type === "notfound" || error.type === "invalid") {
            process.nextTick(function() {
              var data;
              data = setback();
              return this.set(key, data, options, callback);
            });
          }
          return error;
        } else {
          return value;
        }
      });
    };

    ShortMemory.prototype.destroy = function(key, callback) {
      return callback(delete this.heap[key]);
    };

    ShortMemory.prototype.prune = function() {
      var count, i, key, memorable, overCount, overSize, prunable, size, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      clearTimeout(this.timer);
      _ref = this.heap;
      for (key in _ref) {
        memorable = _ref[key];
        if (!memorable.isGood) {
          prunable.push(key);
        }
      }
      for (key = _i = 0, _len = prunable.length; _i < _len; key = ++_i) {
        i = prunable[key];
        this.destroy(key);
      }
      if (this.maxCount !== 0) {
        count = Object.keys(this.heap).length;
        if (count > this.maxCount) {
          overCount = count - this.maxCount;
          prunable = Object.keys(this.heap).slice(0, overCount);
          for (key = _j = 0, _len1 = prunable.length; _j < _len1; key = ++_j) {
            i = prunable[key];
            this.destroy(key);
          }
        }
      }
      if (this.maxSize !== 0) {
        size = this.calculateSize();
        if (size > this.maxSize) {
          overSize = size - this.maxSize;
          prunable = [];
          _ref1 = this.heap;
          for (key in _ref1) {
            memorable = _ref1[key];
            prunable.push(key);
            overSize -= memorable.size;
            if (overSize <= 0) {
              break;
            }
          }
          for (key = _k = 0, _len2 = prunable.length; _k < _len2; key = ++_k) {
            i = prunable[key];
            this.destroy(key);
          }
        }
      }
      return this.timer = setTimeout(function() {
        return this.prune;
      }, this.pruneTime);
    };

    ShortMemory.prototype.calculateSize = function() {
      var i, memorable, size, _ref;
      size = 0;
      _ref = this.heap;
      for (i in _ref) {
        memorable = _ref[i];
        size += memorable.Size;
      }
      return size;
    };

    return ShortMemory;

  })();

  module.exports = ShortMemory;

}).call(this);
